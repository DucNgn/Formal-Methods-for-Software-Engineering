\newpage

\section{Problem 4 (12 pts)}

\subsection{Description:}

Consider list $\Lambda = \langle w, x, y, z \rangle$, deployed to implement a Queue Abstract Data Type.

\begin{enumerate}

\item Let the head of $\Lambda$ correspond to the front position of the Queue. Implement operations \texttt{enqueue(el, $\Lambda$)} and \texttt{dequeue($\Lambda$)} using list construction operations. In both cases we can refer to $\Lambda'$ as the state of the list upon successful termination of one of its operations.

\item Let us now reverse the way we manipulate our data structure and let the head of $\Lambda$ correspond to the rear of the Queue.
\begin{enumerate}
\item What would be the result of $cons(el, \Lambda)$, and would it be a correct implementation for operation \texttt{enqueue(el, $\Lambda$)}?
\item What would be the result of $list(el, \Lambda)$, and would it be a correct implementation for operation \texttt{enqueue(el, $\Lambda$)}?
\item What would be the result of $concat(list(el), \Lambda)$, and would it be a correct implementation for operation \texttt{enqueue(el, $\Lambda$)}?
\end{enumerate}
\end{enumerate}


\subsection{Enqueue and dequeue operations with head of list as front of queue}

\subsubsection{enqueue(el, $\Lambda$)}
\begin{itemize}
    \item[] $\Lambda$' = concat($\Lambda$, list(el));
\end{itemize}

\subsubsection{dequeue($\Lambda$)}
\begin{itemize}
    \item element = head($\Lambda$);
    \item $\Lambda$' = tail($\Lambda$);
    \item[] where 'element' is the return value of the operation.
\end{itemize}



\subsection{Let head of A correspond to the rear of Queue}

\subsubsection{cons(el, $\Lambda$)}
\begin{enumerate}
    \item[] \textbf{Result:} $\langle el, w, x, y, z \rangle$
    \item[] It's the correct implementation for operation \texttt{enqueue(el $\Lambda$)} since it adds the new element to the rear of the queue (head of $\Lambda$). Hence, it is acceptable since it implements the Queue protocol.
\end{enumerate}

\subsubsection{list(el, $\Lambda$)}
\begin{enumerate}
    \item[] \textbf{Result:} $\langle el, \langle w, x, y, z \rangle \rangle$
    \item[] It's \textbf{not} the correct implementation for operation \texttt{enqueue(el $\Lambda$)} since it creates list containing A as a list inside. Hence, it is not acceptable because it does not implement the Queue protocol.
\end{enumerate}

\subsubsection{concat(list(el), $\Lambda$)}
\begin{enumerate}
    \item[] \textbf{Result:} $\langle el, w, x, y, z \rangle$
    \item[] It's the correct implementation for operation \texttt{enqueue(el $\Lambda$)} since it adds the new element to the rear of the queue (head of $\Lambda$). Hence, it is acceptable since it implements the Queue protocol.
\end{enumerate}
